                                                           CALL STACK
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Basic Questions:

1. What is the JavaScript call stack?

  The JavaScript call stack is a mechanism for managing the execution of function calls. When a function is invoked, 
  it is placed on top of the call stack. The engine executes the function, and when it's finished, it is removed from the stack. 
  This ensures that the functions are executed in the correct order.

2. How does the call stack work in JavaScript?

  The call stack follows the LIFO (Last In, First Out) principle. When a function is called, it gets pushed onto the top of the stack. 
  The engine starts executing the function. If the function calls another function, that new function is also pushed onto the stack. 
  Once a function finishes execution, it gets popped off the stack, and control returns to the previous function.

3. What happens when a function is called in JavaScript in terms of the call stack?

  When a function is called, a new execution context is created for that function. This execution context is placed on the top of the call stack. 
  The function executes, and once it completes, its execution context is removed (popped off) from the stack, and the control goes back to the previous execution context.

4. Can you explain what happens when a function calls itself recursively?

  In recursion, each recursive function call creates a new execution context that is pushed onto the call stack.
  The stack grows with each recursive call until the base case is reached, where the recursive calls start to unwind, and the execution contexts are popped off the stack.

5. What is a stack overflow, and how does it occur in the call stack?

  A stack overflow occurs when the call stack exceeds its limit. This typically happens in cases of excessive recursion or when a function calls itself infinitely without a base case. 
  The browser or environment limits the size of the stack, and exceeding this limit results in a stack overflow error.

Intermediate Questions:

1. How does the JavaScript call stack handle asynchronous operations like setTimeout or fetch?

  Asynchronous operations are not executed in the call stack directly. When an asynchronous function (like setTimeout or fetch) is called, 
  it is offloaded to the browser's Web APIs (or Node.js runtime). The call stack continues executing other code, and once the asynchronous operation completes, 
  the callback or promise is placed in the event queue. The event loop then pushes this callback back into the call stack for execution when the stack is empty.

2. What happens when a function in the call stack encounters an error? How is this handled?

  When a function in the call stack encounters an error, the error propagates up the stack to the point where it is handled (using a try...catch block, for example). 
  If the error is not caught, it continues to bubble up the stack until it reaches the global context. If the error is still unhandled,
  it usually results in a crash or termination of the script.

3. Explain the difference between the call stack and the event loop in JavaScript.

  The call stack is responsible for keeping track of function calls and execution order, while the event loop manages asynchronous tasks.
  The event loop monitors the call stack and the event queue. When the stack is empty, the event loop pushes the first task in the queue
  onto the call stack for execution, thus ensuring asynchronous operations are executed when the synchronous code finishes.

4. How does the call stack interact with the execution context in JavaScript?

  Every time a function is invoked, an execution context is created and placed on the call stack. The execution context contains details 
  like variable environments, this binding, and the current execution phase. The topmost execution context on the call stack is the one being executed at any given moment.

Advanced Questions:

1. What role does the execution context play in relation to the call stack?

  The execution context is the environment in which a function executes. Each time a function is called,
  a new execution context is created and pushed onto the call stack. This context contains details like the function’s scope, variables, and the value of this.
  As the function completes, its execution context is removed from the stack.

2. How does tail call optimization affect the call stack in modern JavaScript engines?

  Tail call optimization (TCO) allows JavaScript engines to optimize recursive function calls, 
  specifically tail calls (the last operation in a function). With TCO, instead of adding a new frame to the call stack for each tail call, 
  the engine reuses the current stack frame. This prevents stack overflows and reduces memory consumption in certain recursive functions.

3. Explain how stack frames are used within the call stack. How does this affect memory management?

  A stack frame is a portion of the call stack that contains information related to the function call, such as the function's parameters, local variables, and return address. 
  Every time a function is called, a new stack frame is added. Stack frames are temporary, meaning they are created when the function
  is invoked and destroyed when the function completes. This helps with efficient memory management since unused memory is reclaimed after the function finishes.

4. Describe how the call stack behaves during recursive calls in a deeply nested function.

  During deeply nested recursive calls, each call adds a new execution context to the call stack. If the recursion is deep enough 
  (for example, due to an improperly defined base case), it can lead to a stack overflow error because the stack has a finite size.
  Properly handled recursion will eventually unwind the stack as each recursive call returns, reducing the stack size.

5. Can you walk through the lifecycle of an asynchronous operation in JavaScript, from the call stack to the event loop and callback queue?

  Call Stack: When an asynchronous function (e.g., fetch, setTimeout) is invoked, the call is placed on the call stack.

  Web API: The asynchronous task is handed off to the Web API (in browsers) or a similar environment (in Node.js) to be processed outside the call stack.

  Call Stack Continues: The call stack moves on to execute other code while the asynchronous task runs in the background.

  Task Completion: Once the asynchronous operation finishes, the result (callback or promise) is placed into the callback queue.

  Event Loop: The event loop monitors the call stack. If the call stack is empty, it pulls the first task from the callback queue and pushes it onto the call stack for execution.

  Call Stack Execution: The callback function is executed on the call stack, completing the lifecycle of the asynchronous operation.


                                                          HOISTING
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Basic Questions:

1. What is hoisting in JavaScript?

  Hoisting is a JavaScript behavior where variable and function declarations are moved to the top of their 
  containing scope (global or function scope) during the compilation phase, before the code is executed. 
  This means that declarations are processed before any code is executed, allowing variables and functions 
  to be used before they are actually declared in the code.

2. How does hoisting affect function declarations?

  Function declarations are fully hoisted. Both the function's name and body are moved to the top of their scope.
  This means you can call the function before its declaration in the code because the entire function is available throughout its scope.

    Example:
              greet(); // Works fine, outputs "Hello!"
              
              function greet() {
                console.log("Hello!");
              }

3. How does hoisting affect variables declared with var?

  Variables declared with var are hoisted to the top of their scope, but only the declaration is hoisted, not the initialization. 
  The variable is initialized with undefined until the assignment is reached.
    
    Example:
              console.log(x); // undefined
              var x = 10;
              console.log(x); // 10

4. What happens when you access a variable declared with var before its declaration?

  When you access a var variable before its declaration, the value is undefined because the declaration is 
  hoisted but not the initialization. The variable exists, but it hasn’t been assigned a value yet.
  
    Example:
                console.log(x); // undefined
                var x = 5;

5. How does hoisting work with let and const?

  let and const declarations are hoisted to the top of their block scope (inside functions, if blocks, etc.), 
  but they are not initialized. They remain in a temporal dead zone (TDZ) from the start of the block until their
  declaration is encountered. Accessing these variables before their declaration results in a ReferenceError.
  
    Example:
              console.log(y); // ReferenceError: Cannot access 'y' before initialization
              let y = 10;

Intermediate Questions:

1. Can you explain the difference between hoisting of var and let/const declarations?

  var: Declarations are hoisted to the top of their scope and initialized with undefined. 
  This allows the variable to be accessed before its declaration with an undefined value.
  let/const: Declarations are hoisted to the top of their block scope but not initialized. 
  They exist in the temporal dead zone until the declaration is encountered, leading to a ReferenceError if accessed early.

2. What is the temporal dead zone (TDZ), and how does it relate to hoisting?

  The temporal dead zone (TDZ) is the period between the start of the block scope and the point where the 
  let or const variable is declared. During this time, accessing the variable results in a ReferenceError because the
  variable is in an uninitialized state and cannot be accessed.

3. How does hoisting affect function expressions and arrow functions?

  Function expressions and arrow functions are not fully hoisted like function declarations. 
  Only the variable declaration (var, let, or const) is hoisted, not the function assignment. 
  Attempting to call the function before the assignment will result in a TypeError or ReferenceError.
  
      Example:
              console.log(foo); // undefined (for var) or ReferenceError (for let/const)
              var foo = function() { console.log("Function expression"); };
              
              foo(); // Outputs "Function expression"

4. Can you give an example where hoisting can lead to unexpected results in JavaScript code?

  An example of unexpected results due to hoisting is when you have a variable declared with var that is used before its initialization.
  
      Example:
              console.log(a); // undefined
              var a = 3;
  
  Here, a is hoisted and initialized with undefined, so the first console.log outputs undefined rather than throwing an error.

5. What will be the output of the following code and why?

    console.log(foo);
    var foo = 1;
    function foo() {}
    console.log(foo);
    
    
    Output:
    [Function: foo]
    1
    
    Explanation: The function declaration function foo() {} is hoisted completely, so foo is initially a function. 
    When var foo = 1; is executed, it overwrites foo with the value 1. Hence, the first console.log outputs the 
    function (because of hoisting), and the second console.log outputs 1 after the assignment.

Advanced Questions:

1. How does hoisting interact with block-scoped variables inside functions?

  Block-scoped variables (let and const) are hoisted to the top of their block scope, but they are not initialized until the
  declaration is reached. They remain in the TDZ until then. Inside functions, this means you can only access them after their declaration.

2. Can you explain hoisting behavior with variables declared inside blocks (e.g., within an if statement)?

  Variables declared with var inside a block (like if statements) are hoisted to the function or global scope, not the block itself. 
  In contrast, let and const are hoisted to the block scope and are subject to the TDZ within that block.
  
    Example:
            if (true) {
              var a = 1;
              let b = 2;
            }
            console.log(a); // 1 (var is hoisted to the function/global scope)
            console.log(b); // ReferenceError (b is block-scoped and in TDZ outside the block)

3. How does JavaScript handle hoisting in nested functions?

  In nested functions, each function's declarations are hoisted within their respective scopes. The inner function’s declarations 
  are hoisted within the inner function’s scope, and outer function declarations are hoisted in their scope.
  
    Example:
              function outer() {
                console.log(inner); // undefined (due to hoisting of var declaration)
                var inner = function() { console.log("Inner function"); };
                inner(); // Outputs "Inner function"
              }
              outer();

4. What is the role of the execution context in relation to hoisting?

  The execution context is created during the compilation phase and is responsible for managing the scope of variable and function declarations. 
  During this phase, declarations are hoisted to the top of their respective execution contexts. Each execution context has its own hoisting mechanism, 
  managing its own variables and functions.

5. How does the hoisting behavior differ in different environments, such as browsers and Node.js?

  Hoisting behavior in terms of variable and function declarations is consistent across different JavaScript environments like browsers and Node.js.
  However, there may be differences in how these environments handle the global scope and module scope.
  For example, Node.js modules use CommonJS module system, where variables and functions are not hoisted across module boundaries, 
  while in the browser, global variables and functions are hoisted in the global scope.



                                                             CLOSURES
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


Basic Concept Questions


1. What is a closure in JavaScript?

  A closure is a function that "remembers" and retains access to its lexical environment (the scope in which it was created) 
  even after the outer function has finished executing. Closures allow functions to access variables from their outer scope, 
  making them useful for preserving state across function calls.


2. How do closures work in JavaScript?

  Closures work by capturing the lexical environment where the function was created. When a function is returned or passed as a value, 
  it retains access to the variables from its surrounding scope, even when the outer scope has completed execution. 
  This is possible because JavaScript uses lexical scoping, meaning functions access variables based on where they were declared.


3. What is the difference between closures and the global scope?

  In the global scope, variables are accessible anywhere in the code. Closures, however, allow variables to be accessed only by the 
  inner functions that "capture" them. Unlike the global scope, which is accessible by all functions, closures provide function-specific 
  scopes, preserving variables even after the outer function completes execution.


4. Why are closures important in JavaScript?

  Closures are important because they enable data encapsulation, allowing variables to remain private within a function. 
  They are also essential for creating function factories, callbacks, event handlers, and asynchronous code, where it is necessary to preserve state
  across function executions.


Practical Questions


1. What will be the output of the following code?

        function outer() {
            var a = 1;
            function inner() {
                console.log(a);
            }
            a = 2;
            return inner;
        }
        var closure = outer();
        closure();

  The output will be 2. This is because the closure inner captures the reference to variable a, not its initial value.
  By the time closure() is called, the value of a has already been updated to 2 in the outer function, and that's what gets logged.


2. What are common use cases of closures?

  Common use cases include:
  
  Data encapsulation: Using closures to create "private" variables.
  
  Function factories: Creating multiple instances of functions with their own states.
  
  Callbacks and event handlers: Retaining access to variables in asynchronous code.
  
  Currying: Returning partial functions that can be used later.
  
  Memoization: Storing computed results to avoid redundant calculations.


3. How can closures lead to memory leaks in JavaScript?

  Closures can cause memory leaks if they hold references to variables that are no longer needed but aren't garbage collected because 
  they remain in the closure's scope. For example, if a closure references a large object and that closure is kept alive (e.g., through 
  a long-lived event listener), the object may not be freed from memory, causing a leak.

4. Explain the concept of a function factory using closures.

  A function factory is a function that creates and returns other functions, with each returned function having access to variables in the 
  factory function’s scope via closures.

  For example:
  
                    function createMultiplier(multiplier) {
                        return function(x) {
                            return x * multiplier;
                        };
                    }
                    
                    const double = createMultiplier(2);
                    console.log(double(5)); // 10


Code Debugging/Output Questions


1. What will be the output of this code and why?

                    for (var i = 0; i < 3; i++) {
                        setTimeout(function() {
                            console.log(i);
                        }, 1000);
                    }
  
  The output will be 3 printed three times after 1 second. This happens because the variable i is declared with var, 
  meaning it has function scope. By the time the setTimeout callbacks execute, the loop has completed and i has the value 3. 
  To fix this and capture the correct value, you can use an IIFE (Immediately Invoked Function Expression) or use let instead of var:

                  for (let i = 0; i < 3; i++) {
                      setTimeout(function() {
                          console.log(i);
                      }, 1000);
                  }
                  // Outputs 0, 1, 2


2. Consider the following code snippet:

                      function createGreeting(name) {
                          return function() {
                              console.log("Hello, " + name);
                          };
                      }
                      
                      var greetJohn = createGreeting("John");
                      var greetJane = createGreeting("Jane");
                      
                      greetJohn();  // ??
                      greetJane();  // ??

  The output will be:
  
  Hello, John
  Hello, Jane
  
  Each call to createGreeting() creates a new closure that retains the value of name. greetJohn() prints "Hello, John" and greetJane() prints "Hello, Jane".


3. Explain the output of this function:

                    function outer() {
                        var count = 0;
                        return function() {
                            count++;
                            console.log(count);
                        }
                    }
                    
                    var counter1 = outer();
                    counter1(); // ??
                    counter1(); // ??
                    var counter2 = outer();
                    counter2(); // ??
                    counter1(); // ??

  Answer:
  
  1
  2
  1
  3
  Each call to outer() creates a new closure with its own count variable. counter1 and counter2 have independent count variables. So, when counter1 is called twice, 
  it increments its count to 2. When counter2 is called, it starts with its own count at 1. Calling counter1 again increments its count to 3.

Conceptual Questions


1. Can you explain the lexical environment in the context of closures?

  A lexical environment is the environment within which a function is declared. It consists of the variables that are in scope at the time of function creation.
  Closures capture the lexical environment, which allows them to access variables that were in scope when the closure was created, even after the outer function has finished execution.


2. How do closures enable data encapsulation in JavaScript?

  Closures allow variables to be stored in an inner function's scope, effectively making them private. This prevents external access to these variables, 
  creating a form of data encapsulation. The inner function can manipulate the enclosed variables, but outside code cannot directly access or modify them.


3. How does a closure differ from an object?

  Closures and objects both store state, but closures do so in a more functional manner, by capturing variables from their lexical environment.
  Objects store state in properties. Closures are often used when state should be private and immutable from the outside, while objects are used when
  state needs to be mutable and directly accessible via properties.


4. What problems can closures solve that other programming patterns cannot?

  Closures are particularly suited for problems involving:

  Persistent state: Retaining data between function calls without polluting the global scope.

  Currying: Creating partial functions that remember some arguments.

  Private variables: Encapsulating variables that should not be accessible from outside.
  
  Maintaining state in asynchronous operations, where variables need to persist across callbacks or delayed executions.


Advanced Closure Behavior


1. Can closures be created inside loops in JavaScript?

  Yes, closures can be created inside loops. However, because of how var works (function-scoped), closures inside loops often cause 
  unintended behavior by referencing the same variable. Using let or an IIFE (Immediately Invoked Function Expression) ensures that 
  each closure has its own copy of the variable. Example with let:

                  for (let i = 0; i < 3; i++) {
                      setTimeout(function() {
                          console.log(i);
                      }, 1000);
                  }


2. What will be the output of the following code snippet and why?

                    function makeCounter() {
                        let count = 0;
                        return {
                            increment: function() { count++; return count; },
                            reset: function() { count = 0; }
                        };
                    }
                    
                    let counter = makeCounter();
                    console.log(counter.increment()); // ??
                    console.log(counter.increment()); // ??
                    counter.reset();
                    console.log(counter.increment()); // ??

Answer:
  
  1
  2
  1
  
  The closure maintains the count variable across calls to increment() and reset(). When reset() 
  is called, count is set back to 0, so the next call to increment() returns 1.

3. output?

          function z(){
              var b = 900;
              function x(){
                  var a = 7;
                  function y(){
                      console.log(a, b);
                  }
                y();
              }
              x();
            }
          z();

  Answer - 7, 900







