                                                           CALL STACK
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Basic Questions:

1. What is the JavaScript call stack?

  The JavaScript call stack is a mechanism for managing the execution of function calls. When a function is invoked, 
  it is placed on top of the call stack. The engine executes the function, and when it's finished, it is removed from the stack. 
  This ensures that the functions are executed in the correct order.

2. How does the call stack work in JavaScript?

  The call stack follows the LIFO (Last In, First Out) principle. When a function is called, it gets pushed onto the top of the stack. 
  The engine starts executing the function. If the function calls another function, that new function is also pushed onto the stack. 
  Once a function finishes execution, it gets popped off the stack, and control returns to the previous function.

3. What happens when a function is called in JavaScript in terms of the call stack?

  When a function is called, a new execution context is created for that function. This execution context is placed on the top of the call stack. 
  The function executes, and once it completes, its execution context is removed (popped off) from the stack, and the control goes back to the previous execution context.

4. Can you explain what happens when a function calls itself recursively?

  In recursion, each recursive function call creates a new execution context that is pushed onto the call stack.
  The stack grows with each recursive call until the base case is reached, where the recursive calls start to unwind, and the execution contexts are popped off the stack.

5. What is a stack overflow, and how does it occur in the call stack?

  A stack overflow occurs when the call stack exceeds its limit. This typically happens in cases of excessive recursion or when a function calls itself infinitely without a base case. 
  The browser or environment limits the size of the stack, and exceeding this limit results in a stack overflow error.

Intermediate Questions:

1. How does the JavaScript call stack handle asynchronous operations like setTimeout or fetch?

  Asynchronous operations are not executed in the call stack directly. When an asynchronous function (like setTimeout or fetch) is called, 
  it is offloaded to the browser's Web APIs (or Node.js runtime). The call stack continues executing other code, and once the asynchronous operation completes, 
  the callback or promise is placed in the event queue. The event loop then pushes this callback back into the call stack for execution when the stack is empty.

2. What happens when a function in the call stack encounters an error? How is this handled?

  When a function in the call stack encounters an error, the error propagates up the stack to the point where it is handled (using a try...catch block, for example). 
  If the error is not caught, it continues to bubble up the stack until it reaches the global context. If the error is still unhandled,
  it usually results in a crash or termination of the script.

3. Explain the difference between the call stack and the event loop in JavaScript.

  The call stack is responsible for keeping track of function calls and execution order, while the event loop manages asynchronous tasks.
  The event loop monitors the call stack and the event queue. When the stack is empty, the event loop pushes the first task in the queue
  onto the call stack for execution, thus ensuring asynchronous operations are executed when the synchronous code finishes.

4. How does the call stack interact with the execution context in JavaScript?

  Every time a function is invoked, an execution context is created and placed on the call stack. The execution context contains details 
  like variable environments, this binding, and the current execution phase. The topmost execution context on the call stack is the one being executed at any given moment.

Advanced Questions:

1. What role does the execution context play in relation to the call stack?

  The execution context is the environment in which a function executes. Each time a function is called,
  a new execution context is created and pushed onto the call stack. This context contains details like the function’s scope, variables, and the value of this.
  As the function completes, its execution context is removed from the stack.

2. How does tail call optimization affect the call stack in modern JavaScript engines?

  Tail call optimization (TCO) allows JavaScript engines to optimize recursive function calls, 
  specifically tail calls (the last operation in a function). With TCO, instead of adding a new frame to the call stack for each tail call, 
  the engine reuses the current stack frame. This prevents stack overflows and reduces memory consumption in certain recursive functions.

3. Explain how stack frames are used within the call stack. How does this affect memory management?

  A stack frame is a portion of the call stack that contains information related to the function call, such as the function's parameters, local variables, and return address. 
  Every time a function is called, a new stack frame is added. Stack frames are temporary, meaning they are created when the function
  is invoked and destroyed when the function completes. This helps with efficient memory management since unused memory is reclaimed after the function finishes.

4. Describe how the call stack behaves during recursive calls in a deeply nested function.

  During deeply nested recursive calls, each call adds a new execution context to the call stack. If the recursion is deep enough 
  (for example, due to an improperly defined base case), it can lead to a stack overflow error because the stack has a finite size.
  Properly handled recursion will eventually unwind the stack as each recursive call returns, reducing the stack size.

5. Can you walk through the lifecycle of an asynchronous operation in JavaScript, from the call stack to the event loop and callback queue?

  Call Stack: When an asynchronous function (e.g., fetch, setTimeout) is invoked, the call is placed on the call stack.

  Web API: The asynchronous task is handed off to the Web API (in browsers) or a similar environment (in Node.js) to be processed outside the call stack.

  Call Stack Continues: The call stack moves on to execute other code while the asynchronous task runs in the background.

  Task Completion: Once the asynchronous operation finishes, the result (callback or promise) is placed into the callback queue.

  Event Loop: The event loop monitors the call stack. If the call stack is empty, it pulls the first task from the callback queue and pushes it onto the call stack for execution.

  Call Stack Execution: The callback function is executed on the call stack, completing the lifecycle of the asynchronous operation.


                                                          HOISTING
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Basic Questions:

1. What is hoisting in JavaScript?

  Hoisting is a JavaScript behavior where variable and function declarations are moved to the top of their 
  containing scope (global or function scope) during the compilation phase, before the code is executed. 
  This means that declarations are processed before any code is executed, allowing variables and functions 
  to be used before they are actually declared in the code.

2. How does hoisting affect function declarations?

  Function declarations are fully hoisted. Both the function's name and body are moved to the top of their scope.
  This means you can call the function before its declaration in the code because the entire function is available throughout its scope.

    Example:
              greet(); // Works fine, outputs "Hello!"
              
              function greet() {
                console.log("Hello!");
              }

3. How does hoisting affect variables declared with var?

  Variables declared with var are hoisted to the top of their scope, but only the declaration is hoisted, not the initialization. 
  The variable is initialized with undefined until the assignment is reached.
    
    Example:
              console.log(x); // undefined
              var x = 10;
              console.log(x); // 10

4. What happens when you access a variable declared with var before its declaration?

  When you access a var variable before its declaration, the value is undefined because the declaration is 
  hoisted but not the initialization. The variable exists, but it hasn’t been assigned a value yet.
  
    Example:
                console.log(x); // undefined
                var x = 5;

5. How does hoisting work with let and const?

  let and const declarations are hoisted to the top of their block scope (inside functions, if blocks, etc.), 
  but they are not initialized. They remain in a temporal dead zone (TDZ) from the start of the block until their
  declaration is encountered. Accessing these variables before their declaration results in a ReferenceError.
  
    Example:
              console.log(y); // ReferenceError: Cannot access 'y' before initialization
              let y = 10;

Intermediate Questions:

1. Can you explain the difference between hoisting of var and let/const declarations?

  var: Declarations are hoisted to the top of their scope and initialized with undefined. 
  This allows the variable to be accessed before its declaration with an undefined value.
  let/const: Declarations are hoisted to the top of their block scope but not initialized. 
  They exist in the temporal dead zone until the declaration is encountered, leading to a ReferenceError if accessed early.

2. What is the temporal dead zone (TDZ), and how does it relate to hoisting?

  The temporal dead zone (TDZ) is the period between the start of the block scope and the point where the 
  let or const variable is declared. During this time, accessing the variable results in a ReferenceError because the
  variable is in an uninitialized state and cannot be accessed.

3. How does hoisting affect function expressions and arrow functions?

  Function expressions and arrow functions are not fully hoisted like function declarations. 
  Only the variable declaration (var, let, or const) is hoisted, not the function assignment. 
  Attempting to call the function before the assignment will result in a TypeError or ReferenceError.
  
      Example:
              console.log(foo); // undefined (for var) or ReferenceError (for let/const)
              var foo = function() { console.log("Function expression"); };
              
              foo(); // Outputs "Function expression"

4. Can you give an example where hoisting can lead to unexpected results in JavaScript code?

  An example of unexpected results due to hoisting is when you have a variable declared with var that is used before its initialization.
  
      Example:
              console.log(a); // undefined
              var a = 3;
  
  Here, a is hoisted and initialized with undefined, so the first console.log outputs undefined rather than throwing an error.

5. What will be the output of the following code and why?

    console.log(foo);
    var foo = 1;
    function foo() {}
    console.log(foo);
    
    
    Output:
    [Function: foo]
    1
    
    Explanation: The function declaration function foo() {} is hoisted completely, so foo is initially a function. 
    When var foo = 1; is executed, it overwrites foo with the value 1. Hence, the first console.log outputs the 
    function (because of hoisting), and the second console.log outputs 1 after the assignment.

Advanced Questions:

1. How does hoisting interact with block-scoped variables inside functions?

  Block-scoped variables (let and const) are hoisted to the top of their block scope, but they are not initialized until the
  declaration is reached. They remain in the TDZ until then. Inside functions, this means you can only access them after their declaration.

2. Can you explain hoisting behavior with variables declared inside blocks (e.g., within an if statement)?

  Variables declared with var inside a block (like if statements) are hoisted to the function or global scope, not the block itself. 
  In contrast, let and const are hoisted to the block scope and are subject to the TDZ within that block.
  
    Example:
            if (true) {
              var a = 1;
              let b = 2;
            }
            console.log(a); // 1 (var is hoisted to the function/global scope)
            console.log(b); // ReferenceError (b is block-scoped and in TDZ outside the block)

3. How does JavaScript handle hoisting in nested functions?

  In nested functions, each function's declarations are hoisted within their respective scopes. The inner function’s declarations 
  are hoisted within the inner function’s scope, and outer function declarations are hoisted in their scope.
  
    Example:
              function outer() {
                console.log(inner); // undefined (due to hoisting of var declaration)
                var inner = function() { console.log("Inner function"); };
                inner(); // Outputs "Inner function"
              }
              outer();

4. What is the role of the execution context in relation to hoisting?

  The execution context is created during the compilation phase and is responsible for managing the scope of variable and function declarations. 
  During this phase, declarations are hoisted to the top of their respective execution contexts. Each execution context has its own hoisting mechanism, 
  managing its own variables and functions.

5. How does the hoisting behavior differ in different environments, such as browsers and Node.js?

  Hoisting behavior in terms of variable and function declarations is consistent across different JavaScript environments like browsers and Node.js.
  However, there may be differences in how these environments handle the global scope and module scope.
  For example, Node.js modules use CommonJS module system, where variables and functions are not hoisted across module boundaries, 
  while in the browser, global variables and functions are hoisted in the global scope.



                                                             CLOSURES
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


Basic Concept Questions


1. What is a closure in JavaScript?

  A closure is a function that "remembers" and retains access to its lexical environment (the scope in which it was created) 
  even after the outer function has finished executing. Closures allow functions to access variables from their outer scope, 
  making them useful for preserving state across function calls.


2. How do closures work in JavaScript?

  Closures work by capturing the lexical environment where the function was created. When a function is returned or passed as a value, 
  it retains access to the variables from its surrounding scope, even when the outer scope has completed execution. 
  This is possible because JavaScript uses lexical scoping, meaning functions access variables based on where they were declared.


3. What is the difference between closures and the global scope?

  In the global scope, variables are accessible anywhere in the code. Closures, however, allow variables to be accessed only by the 
  inner functions that "capture" them. Unlike the global scope, which is accessible by all functions, closures provide function-specific 
  scopes, preserving variables even after the outer function completes execution.


4. Why are closures important in JavaScript?

  Closures are important because they enable data encapsulation, allowing variables to remain private within a function. 
  They are also essential for creating function factories, callbacks, event handlers, and asynchronous code, where it is necessary to preserve state
  across function executions.


Practical Questions


1. What will be the output of the following code?

        function outer() {
            var a = 1;
            function inner() {
                console.log(a);
            }
            a = 2;
            return inner;
        }
        var closure = outer();
        closure();

  The output will be 2. This is because the closure inner captures the reference to variable a, not its initial value.
  By the time closure() is called, the value of a has already been updated to 2 in the outer function, and that's what gets logged.


2. What are common use cases of closures?

  Common use cases include:
  
  Data encapsulation: Using closures to create "private" variables.
  
  Function factories: Creating multiple instances of functions with their own states.
  
  Callbacks and event handlers: Retaining access to variables in asynchronous code.
  
  Currying: Returning partial functions that can be used later.
  
  Memoization: Storing computed results to avoid redundant calculations.


3. How can closures lead to memory leaks in JavaScript?

  Closures can cause memory leaks if they hold references to variables that are no longer needed but aren't garbage collected because 
  they remain in the closure's scope. For example, if a closure references a large object and that closure is kept alive (e.g., through 
  a long-lived event listener), the object may not be freed from memory, causing a leak.

4. Explain the concept of a function factory using closures.

  A function factory is a function that creates and returns other functions, with each returned function having access to variables in the 
  factory function’s scope via closures.

  For example:
  
                    function createMultiplier(multiplier) {
                        return function(x) {
                            return x * multiplier;
                        };
                    }
                    
                    const double = createMultiplier(2);
                    console.log(double(5)); // 10


Code Debugging/Output Questions


1. What will be the output of this code and why?

                    for (var i = 0; i < 3; i++) {
                        setTimeout(function() {
                            console.log(i);
                        }, 1000);
                    }
  
  The output will be 3 printed three times after 1 second. This happens because the variable i is declared with var, 
  meaning it has function scope. By the time the setTimeout callbacks execute, the loop has completed and i has the value 3. 
  To fix this and capture the correct value, you can use an IIFE (Immediately Invoked Function Expression) or use let instead of var:

                  for (let i = 0; i < 3; i++) {
                      setTimeout(function() {
                          console.log(i);
                      }, 1000);
                  }
                  // Outputs 0, 1, 2


2. Consider the following code snippet:

                      function createGreeting(name) {
                          return function() {
                              console.log("Hello, " + name);
                          };
                      }
                      
                      var greetJohn = createGreeting("John");
                      var greetJane = createGreeting("Jane");
                      
                      greetJohn();  // ??
                      greetJane();  // ??

  The output will be:
  
  Hello, John
  Hello, Jane
  
  Each call to createGreeting() creates a new closure that retains the value of name. greetJohn() prints "Hello, John" and greetJane() prints "Hello, Jane".


3. Explain the output of this function:

                    function outer() {
                        var count = 0;
                        return function() {
                            count++;
                            console.log(count);
                        }
                    }
                    
                    var counter1 = outer();
                    counter1(); // ??
                    counter1(); // ??
                    var counter2 = outer();
                    counter2(); // ??
                    counter1(); // ??

  Answer:
  
  1
  2
  1
  3
  Each call to outer() creates a new closure with its own count variable. counter1 and counter2 have independent count variables. So, when counter1 is called twice, 
  it increments its count to 2. When counter2 is called, it starts with its own count at 1. Calling counter1 again increments its count to 3.

Conceptual Questions


1. Can you explain the lexical environment in the context of closures?

  A lexical environment is the environment within which a function is declared. It consists of the variables that are in scope at the time of function creation.
  Closures capture the lexical environment, which allows them to access variables that were in scope when the closure was created, even after the outer function has finished execution.


2. How do closures enable data encapsulation in JavaScript?

  Closures allow variables to be stored in an inner function's scope, effectively making them private. This prevents external access to these variables, 
  creating a form of data encapsulation. The inner function can manipulate the enclosed variables, but outside code cannot directly access or modify them.


3. How does a closure differ from an object?

  Closures and objects both store state, but closures do so in a more functional manner, by capturing variables from their lexical environment.
  Objects store state in properties. Closures are often used when state should be private and immutable from the outside, while objects are used when
  state needs to be mutable and directly accessible via properties.


4. What problems can closures solve that other programming patterns cannot?

  Closures are particularly suited for problems involving:

  Persistent state: Retaining data between function calls without polluting the global scope.

  Currying: Creating partial functions that remember some arguments.

  Private variables: Encapsulating variables that should not be accessible from outside.
  
  Maintaining state in asynchronous operations, where variables need to persist across callbacks or delayed executions.


Advanced Closure Behavior


1. Can closures be created inside loops in JavaScript?

  Yes, closures can be created inside loops. However, because of how var works (function-scoped), closures inside loops often cause 
  unintended behavior by referencing the same variable. Using let or an IIFE (Immediately Invoked Function Expression) ensures that 
  each closure has its own copy of the variable. Example with let:

                  for (let i = 0; i < 3; i++) {
                      setTimeout(function() {
                          console.log(i);
                      }, 1000);
                  }


2. What will be the output of the following code snippet and why?

                    function makeCounter() {
                        let count = 0;
                        return {
                            increment: function() { count++; return count; },
                            reset: function() { count = 0; }
                        };
                    }
                    
                    let counter = makeCounter();
                    console.log(counter.increment()); // ??
                    console.log(counter.increment()); // ??
                    counter.reset();
                    console.log(counter.increment()); // ??

Answer:
  
  1
  2
  1
  
  The closure maintains the count variable across calls to increment() and reset(). When reset() 
  is called, count is set back to 0, so the next call to increment() returns 1.

3. output?

          function z(){
              var b = 900;
              function x(){
                  var a = 7;
                  function y(){
                      console.log(a, b);
                  }
                y();
              }
              x();
            }
          z();

  Answer - 7, 900


                                                                        FIRST CLASS FUNCTIONS
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. What are first-class functions in JavaScript?

  First-class functions are functions that are treated as first-class citizens in a programming language. This means that functions can be:
  
   - Assigned to variables: You can store functions in variables like any other value.
   - Passed as arguments: Functions can be passed as arguments to other functions.
   - Returned from other functions: Functions can be returned as values from other functions.
   - Stored in data structures: Functions can be stored in arrays, objects, or other data structures.
  
  In languages that support first-class functions, functions are treated as any other value (such as numbers, strings, or objects), giving you flexibility in how you use and manipulate them.
  
  Example (JavaScript):
  
                function sayHello() {
                  return "Hello!";
                }
                
                // Assigning a function to a variable
                const greet = sayHello;
                console.log(greet()); // Output: Hello!
                
                // Passing a function as an argument
                function callFunction(fn) {
                  return fn();
                }
                console.log(callFunction(sayHello)); // Output: Hello!
                
                // Returning a function from another function
                function createGreeter() {
                  return function() {
                    return "Hi!";
                  };
}
const greeter = createGreeter();
console.log(greeter()); // Output: Hi!


2. How would you pass a function as an argument to another function? Can you give an example?
                  
                  function greet(name) {
                      return `Hello, ${name}`;
                  }
                  
                  function callGreet(fn, name) {
                      return fn(name);
                  }
                  
                  console.log(callGreet(greet, "Bob")); // Output: Hello, Bob

3. What does it mean for a function to return another function? Can you give an example?

            function outerFunction() {
                return function() {
                    console.log("Inner function!");
                };
            }
            
            const inner = outerFunction();
            inner(); // Output: Inner function!

4. Can you explain currying and how it relates to first-class functions?

  Currying is a technique where a function is transformed into a series of functions that each take a single argument. Since functions are first-class,
  you can return functions from other functions to achieve currying.
  
          function multiply(a) {
              return function(b) {
                  return a * b;
              };
          }
          
          const double = multiply(2);
          console.log(double(5)); // Output: 10

5. What is a callback function, and how does it relate to first-class functions?

  A callback function is a function passed as an argument to another function, which is then invoked inside that function. This is possible because functions are first-class.
  
              function doSomething(callback) {
                  callback();
              }
              
              doSomething(function() {
                  console.log("Callback executed!");
              });

6. How do first-class functions enable the use of asynchronous patterns like setTimeout and Promise.then?

  Functions can be passed as arguments to setTimeout, Promise.then, and other asynchronous functions. 
  These asynchronous patterns rely on first-class functions to delay execution until a certain event or time.
  
            setTimeout(function() {
                console.log("Executed after 1 second!");
            }, 1000);
            
            const promise = new Promise((resolve) => resolve("Success!"));
            promise.then(function(result) {
                console.log(result); // Output: Success!
            });


7. How would you explain the concept of function composition using first-class functions?
  
  Function composition is the process of combining multiple functions to produce a new function. Since functions are first-class, you can pass them to other functions and return them to create a chain of function calls.
  
          const compose = (f, g) => (x) => f(g(x));
          const add2 = (x) => x + 2;
          const multiply3 = (x) => x * 3;
          
          const addAndMultiply = compose(multiply3, add2);
          console.log(addAndMultiply(5)); // Output: 21 (5 + 2 = 7, 7 * 3 = 21)




                                                                          CALLBACK FUNCTIONS
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


1. What is a callback function in JavaScript?

  A callback function is a function that is passed as an argument to another function and is executed after some operation in the calling function is complete.

2. Can you give an example of a callback function in JavaScript?

            function greet(name) {
                console.log(`Hello, ${name}`);
            }
            
            function processInput(callback) {
                const name = "Alice";
                callback(name);
            }
            
            processInput(greet);  // Output: Hello, Alice

3. Why are callback functions important in JavaScript?

  Callback functions are crucial for handling asynchronous tasks, such as network requests, timers, or event handling. They allow you to wait for a task to complete
  before executing the next piece of code.

4. What is the difference between synchronous and asynchronous callbacks?

  Synchronous callbacks are executed immediately as part of the execution of the function they are passed to.
  Asynchronous callbacks are executed after an event occurs or when the operation completes (e.g., when fetching data from a server).

  // Synchronous callback
                [1, 2, 3].forEach(function(num) {
                    console.log(num); // Outputs 1, 2, 3 immediately
                });

  // Asynchronous callback
            setTimeout(function() {
                console.log("Async callback!"); // Outputs after 1 second
            }, 1000);

5. How would you handle errors in a callback function?

  Errors in callbacks can be handled by passing an error argument to the callback. If an error occurs, the callback function can check for the presence of an error and 
  handle it accordingly.

              function fetchData(callback) {
                  const error = false;
                  const data = { name: "Alice", age: 25 };
                  
                  if (error) {
                      callback("Error occurred", null);
                  } else {
                      callback(null, data);
                  }
              }
              
              fetchData(function(err, data) {
                  if (err) {
                      console.log(err);
                  } else {
                      console.log(data);
                  }
              });

6. What are some common problems with callback functions? How can you overcome them?

  Common problems with callbacks include callback hell (deeply nested callbacks making code difficult to read and maintain) and error handling across multiple asynchronous steps. 
  To overcome these, you can use promises or async/await to manage asynchronous code more cleanly.

7. What is "callback hell," and how can it be avoided?

  Callback hell occurs when you have many nested callback functions, making the code difficult to read and maintain. It can be avoided by breaking down the code into smaller functions,
  using promises, or utilizing async/await.

  Example of callback hell:

            setTimeout(function() {
                console.log("First task");
                setTimeout(function() {
                    console.log("Second task");
                    setTimeout(function() {
                        console.log("Third task");
                    }, 1000);
                }, 1000);
            }, 1000);

  Avoiding callback hell with promises:

          new Promise((resolve) => setTimeout(() => resolve("First task"), 1000))
              .then(console.log)
              .then(() => new Promise((resolve) => setTimeout(() => resolve("Second task"), 1000)))
              .then(console.log)
              .then(() => new Promise((resolve) => setTimeout(() => resolve("Third task"), 1000)))
              .then(console.log);

8. What is the difference between callbacks and promises?

  Callbacks are functions passed to other functions to be executed later, once the task is complete.
  Promises represent the eventual completion (or failure) of an asynchronous operation and its resulting value. Promises provide better readability and help avoid callback hell.

9. How would you convert a function that uses callbacks into one that uses promises?

  You can wrap the callback-based function in a promise by using the Promise constructor. Here's an example:

          function fetchData(callback) {
              setTimeout(() => {
                  callback(null, { name: "Alice", age: 25 });
              }, 1000);
          }

  // Convert to promise-based
          function fetchDataPromise() {
              return new Promise((resolve, reject) => {
                  fetchData((err, data) => {
                      if (err) {
                          reject(err);
                      } else {
                          resolve(data);
                      }
                  });
              });
          }
          
          fetchDataPromise()
              .then((data) => console.log(data))
              .catch((err) => console.log(err));

10. Can you explain the differences between a higher-order function and a callback function?

  A callback function is a function passed as an argument to another function and executed at a certain point. A higher-order function is a function 
  that accepts other functions as arguments or returns a function. Callback functions can be used within higher-order functions, but the two are distinct concepts.

11. How are event listeners and callbacks related?

  Event listeners in JavaScript use callback functions to define the behavior that occurs when an event happens (e.g., when a button is clicked).
  The callback function is triggered when the specified event occurs.

          const button = document.querySelector("button");
          
          button.addEventListener("click", function() {
              console.log("Button clicked!");
          });

12. What is an asynchronous callback? How is it different from a synchronous callback?

  An asynchronous callback is executed after an asynchronous operation completes, like an API request or timer.
  A synchronous callback is executed immediately within the same operation, without waiting for any background tasks.



                                                                           EVENT LISTENERS
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. What is an event listener in JavaScript?

  An event listener is a function that waits for a specific event (such as a click, keypress, or form submission) to occur on an element. Once the event occurs, 
  the callback function associated with the listener is executed.

2. What is the difference between onclick and addEventListener()?

  onclick is an HTML attribute or a DOM property that can only attach one event handler at a time. If another handler is assigned, it overwrites the previous one.
  addEventListener() allows attaching multiple event listeners of the same type to an element without overriding existing listeners.
  
  // Using onclick (only one listener allowed)
  button.onclick = function() { alert('Clicked 1'); };
  button.onclick = function() { alert('Clicked 2'); }; // This overwrites the first
  
  // Using addEventListener (multiple listeners allowed)
  button.addEventListener('click', function() { alert('Clicked 1'); });
  button.addEventListener('click', function() { alert('Clicked 2'); });

3. How would you remove an event listener?
  
  Event listeners are removed using the removeEventListener() method. The function passed to removeEventListener() must be the exact same reference that was passed to addEventListener().
  
            function handleClick() {
                alert('Button clicked!');
            }
            
            button.addEventListener('click', handleClick);
            button.removeEventListener('click', handleClick); // Removes the listener

4. What is the third argument in addEventListener() used for?

  The third argument, useCapture, is a boolean that controls the event's phase. If true, the event listener is set during the capturing phase. 
  If false, the listener is set during the bubbling phase (default).
  
  
  element.addEventListener('click', callback, true);  // Capturing phase
  element.addEventListener('click', callback, false); // Bubbling phase (default)

5. What are the capturing and bubbling phases in event propagation?

  Capturing phase: The event travels from the document root down to the target element.
  Bubbling phase: The event travels back up from the target element to the document root.
  Event listeners can be set for either phase using the third argument in addEventListener().
  
  
  // Example of bubbling phase
          parentElement.addEventListener('click', () => console.log('Parent clicked'));
          childElement.addEventListener('click', () => console.log('Child clicked'));

6. Explain event.stopPropagation() and event.preventDefault() with examples.

  stopPropagation() prevents the event from propagating (bubbling or capturing) to ancestor elements.
  preventDefault() prevents the default action associated with the event (e.g., preventing a form submission).
  
      // stopPropagation example
      childElement.addEventListener('click', (event) => {
          event.stopPropagation();  // Prevents the event from bubbling to parentElement
      });
      
      // preventDefault example
      formElement.addEventListener('submit', (event) => {
          event.preventDefault();  // Prevents the form from being submitted
      });

7. How can you handle multiple events with a single event listener?

  Multiple events can be handled with a single listener by either checking the event type or using an array of event types with a loop.
  
    // Example 1: Checking event type
    element.addEventListener('click', (event) => {
        if (event.type === 'click') {
            console.log('Element clicked');
        } else if (event.type === 'mouseover') {
            console.log('Mouse over element');
        }
    });
    
    // Example 2: Loop through event types
    ['click', 'mouseover'].forEach((eventType) => {
        element.addEventListener(eventType, () => console.log(eventType));
    });

8. How do you delegate events in JavaScript?

  Event delegation is a technique where you attach a single event listener to a parent element and handle the event for its child elements.
  This reduces the number of listeners and is useful when handling events for dynamically created elements.
  Example:
  
      document.querySelector('ul').addEventListener('click', (event) => {
          if (event.target.tagName === 'LI') {
              console.log('List item clicked:', event.target.textContent);
          }
      });

9. What happens if you attach an event listener to a dynamically added element?
  
  If an element is added to the DOM dynamically after the event listener was attached, it will not inherit the listener unless the event listener was 
  attached using event delegation. To handle dynamically added elements, you should attach the listener to a common parent element.

10. Can you attach an event listener to multiple elements at once?

  You cannot directly attach an event listener to multiple elements, but you can loop through the elements and attach listeners to each individually.
    
      const buttons = document.querySelectorAll('button');
      buttons.forEach(button => {
          button.addEventListener('click', () => {
              console.log('Button clicked!');
          });
      });

11. What are synthetic events in React, and how do they differ from native events?
  
  In React, synthetic events are cross-browser wrappers around the browser's native events. They provide consistent behavior across different browsers. 
  Synthetic events work the same way as native events but are handled within the React framework.

12. How does JavaScript handle event listeners for the same event type on the same element?

  If you add multiple event listeners for the same event type on the same element using addEventListener(), all the listeners will be triggered in the order they were added. 
  If you assign a function directly using onclick, only the most recent listener will be active (since it overwrites the previous ones).

13. What is an anonymous function in the context of an event listener, and what are the implications?

  An anonymous function is a function without a name that is directly passed to addEventListener(). The downside of using anonymous functions is that they cannot be removed later 
  using removeEventListener() since they don’t have a reference.
  
      button.addEventListener('click', function() {
          console.log('Anonymous function');
      });
  
  // This cannot be removed with removeEventListener

14. Can event listeners be applied to non-DOM elements?

  Yes, event listeners can be applied to non-DOM objects like window, document, and even certain objects in Node.js like EventEmitter.

15. What is the once option in addEventListener()?

  The once option in addEventListener() ensures that the event listener is called at most once after being added. Once the event has been triggered, the listener is automatically removed.
  
    button.addEventListener('click', () => {
        console.log('This will run only once!');
    }, { once: true });
      



